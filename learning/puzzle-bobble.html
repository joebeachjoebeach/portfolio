<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Puzzle Bobble</title>
	<link rel="icon" type="image/x-icon" href="../media/favicon.ico">
	<script src="https://cdn.rawgit.com/stevekrouse/WoofJS/a1a059a9/dist/woof.js"></script>
</head>

<body>
			
<script>
setBackdropColor("#778899")
setBackdropStyle('cover')

var frame = new Rectangle({
  height: 560,
  width: 470
})


var screen = new Rectangle({
  color: "#FCF3E7",
  height: 540,
  width: 450
})

var base = new Rectangle({
  color: "#000",
  width: 450,
  height: 75,
  y: -233
})

var upNext = new Text({
  text: "Next bubble:",
  color: "white",
  size: 15,
  y: -230,
  x: -180
})

var arrow = new Image({
  url: "https://openclipart.org/image/2400px/svg_to_png/241063/Golden-Arrow-2-No-Background.png",
  width: 140,
  height: 30,
  angle: 90,
  y: -200
})

var colors = [
  "#F0A202",
  "#399E5A",
  "#B71C19",
  "#A5338B",
  "#2E6197"
]

var ys = [242, 194, 146, 98, 50, 2, -46, -94, -142, -190]
var xs = [
  [-193, -138, -83, -28, 27, 82, 137, 192],
  [-165, -110, -55, 0, 55, 110, 165]
]

var bubbles
var bubbleX
var bubbleY
var playerBubble
var nextBubble
var topRowEight
var frozen
var gameOverText
var pressSpace

var timerBarFrame = new Rectangle({
  width: 470,
  height: 50,
  y: 310
})
var timerBar = new Rectangle({
  height: 42,
  width: 2,
  color: colors[1],
  y: 310,
  x: -230
})

function initialize() {
  frozen = false
  bubbles = []
  bubbleX = -193
  bubbleY = 242
  for (var j = 0; j < 4; j++) {
    if (bubbleX === -193) {
      for (var i = 0; i < 8; i++) {
        bubbles.push(new Circle({
          x: bubbleX,
          y: bubbleY,
          radius: 28,
          color: colors[random(0, 4)]
        }))
        bubbleX += 55
      }
    }
    if (bubbleX === -165) {
      for (var k = 0; k < 7; k++) {
        bubbles.push(new Circle({
          x: bubbleX,
          y: bubbleY,
          radius: 28,
          color: colors[random(0, 4)]
        }))
        bubbleX += 55
      }
    }
    bubbleY -= 48
    if (bubbleX === 247) {
      bubbleX = -165
    } else {
      bubbleX = -193
    }
  }
  playerBubble = new Circle({
    x: 0,
    y: -200,
    radius: 28,
    color: colors[random(0, 4)]
  })
  playerBubble.touchingBubbles = []
  
  nextBubble = new Circle({
    x: -100,
    y: -233,
    radius: 28,
    color: colors[random(0, 4)]
  })
  nextBubble.touchingBubbles = []
  
  bubbles.forEach(bubble => {
    findTouchingBubbles(bubble, bubbles)
  })
  
  topRowEight = true
  timerBar.width = 2
  timerBar.x = -230
  
}

initialize()

forever(() => {
  if (!frozen) {
    if (keysDown.includes('left')) {
      arrow.turnLeft(2)
    }
    if (keysDown.includes('right')) {
      arrow.turnRight(2)
    }
    if (arrow.angle >= 175) {
      arrow.angle = 174
    }
    if (arrow.angle <= 5) {
      arrow.angle = 6
    }
  } 
})

var gameOver = false
var shooting = false

// shooting
onKeyDown(() => {
  if (keysDown.includes('space') && !shooting && !frozen) {
    shooting = true
    playerBubble.angle = arrow.angle
    var touching = false
    repeatUntil(() => touching, () => {
      // move the bubble
      playerBubble.move(10)

      // bounce off the walls
      if (playerBubble.x > 220) {
        playerBubble.x = 190
        playerBubble.angle = 180 - playerBubble.angle
      }
      if (playerBubble.x < -220) {
        playerBubble.x = -190
        playerBubble.angle = 180 - playerBubble.angle
      }

      // stop at the top
      if (playerBubble.y >= 242) {
        touching = true
      }

      // check if touching an existing bubble and stop there
      bubbles.forEach(bubble => {
        if (bubble.distanceTo(playerBubble) < 57) {
          touching = true
          findTouchingBubbles(playerBubble, bubbles)
        }
      })
    }, () => {

      // line up playerBubble on the grid
      playerBubble.y = closestCoordinate(ys, playerBubble.y)
      
      // if the top row has eight bubbles
      if (topRowEight) {
        if (ys.indexOf(playerBubble.y) % 2) {
          playerBubble.x = closestCoordinate(xs[1], playerBubble.x)
        }
        else {
          playerBubble.x = closestCoordinate(xs[0], playerBubble.x)
        }
      }
      
      // if the top row has seven bubbles
      else {
        if (ys.indexOf(playerBubble.y) % 2) {
          playerBubble.x = closestCoordinate(xs[0], playerBubble.x)
        }
        else {
          playerBubble.x = closestCoordinate(xs[1], playerBubble.x)
        }
      }

      // add the shot bubble to the list of bubbles
      bubbles.push(playerBubble)

      // identify all bubbles of this color
      var sameColorBubbles = bubbles.filter(function (bubble) {
        return bubble.color == playerBubble.color && bubble != playerBubble
      })

      findMatchingBubbles(playerBubble, sameColorBubbles)
      var matches = bubbles.filter(function (bubble) {
        return bubble.match
      })

      // if there are more than 2 same color bubbles touching, get rid of them
      if (matches.length > 2) {
        matches.forEach(bubble => {
          bubbles.splice(bubbles.indexOf(bubble), 1)
          pop(bubble)
        })
      } else {
        matches.forEach(bubble => {
          bubble.match = false
        })
      }

      // load the next bubble into the shooter
      playerBubble = nextBubble
      playerBubble.x = arrow.x
      playerBubble.y = arrow.y

      // make the next bubble on deck
      nextBubble = new Circle({
        x: -100,
        y: -233,
        radius: 28,
        color: colors[random(0, 4)]
      })
      nextBubble.touchingBubbles = []
      shooting = false
    })
  }
})

every(0.2, 'second', () => {
  if (!frozen) {
   timerBar.width += 2
    timerBar.x += 1
    if (timerBar.width >= 462) {
      timerBar.width = 2
      timerBar.x = -230
      // drop the bubbles down
      bubbles.forEach(bubble => {
        bubble.y -= 48
      })
      // add the appropriate top row
      if (!topRowEight) {
        bubbleX = -193
        for (var i = 0; i < 8; i++) {
          bubbles.push(new Circle({
            x: bubbleX,
            y: 242,
            radius: 28,
            color: colors[random(0, 4)]
          }))
          bubbleX += 55
        }
      }
      else {
        bubbleX = -165
        for (var j = 0; j < 7; j++) {
          bubbles.push(new Circle({
            x: bubbleX,
            y: 242,
            radius: 28,
            color: colors[random(0, 4)]
          }))
          bubbleX += 55
        }
      }
      topRowEight = !topRowEight
    } 
  }
})

forever(() => {
  bubbles.forEach(bubble => {
    if (bubble.y < arrow.y + 28 && !frozen) {
      gameOverText = new Text({
        text: "Game Over!",
        size: 42
      })
      pressSpace = new Text({
        text: "Press enter to play again",
        y: -50,
        size: 24
      })
      gameOver = true
      frozen = true
    }
  })
  if (bubbles.length === 0 && !frozen) {
    gameOver = true
    frozen = true
    after(1, 'second', () => {
        console.log("you win")
        gameOverText = new Text({
          text: "You Win!",
          size: 42
        })
        pressSpace = new Text({
          text: "Press enter to play again",
          y: -50,
          size: 24
        })
    })    
  }
})

onKeyDown(() => {
  if (keysDown.includes('enter') && gameOver) {
    gameOver = false
    playerBubble.delete()
    nextBubble.delete()
    bubbles.forEach(bubble => {
      bubble.delete()
    })
    initialize()
    gameOverText.hide()
    pressSpace.hide()
    frozen = false
  }
})

function closestCoordinate(array, currentCoordinate) {
  return array.reduce(function (min, cur) {
    if (Math.abs(cur - currentCoordinate) < Math.abs(min - currentCoordinate))
      return cur
    return min
  })
}

function findMatchingBubbles(sprite, list) {
  list.forEach(bubble => {
    if (bubble.distanceTo(sprite) < 58 && bubble != sprite && !bubble.match) {
      bubble.match = true
      sprite.match = true
      findMatchingBubbles(bubble, list)
    }
  })
}

function findTouchingBubbles(sprite, list) {
  sprite.touchingBubbles = []
  list.forEach(bubble => {
    if (bubble.distanceTo(sprite) < 58 && bubble != sprite) {
      sprite.touchingBubbles.push(bubble)
    }
  })
}

function isConnected(sprite) {
  if (sprite.top) {
    return true
  }
  sprite.touchingBubbles.forEach(bubble => {
    isConnected(bubble)
  })
}

function markAllConnected(topBubble) {
  topBubble.touchingBubbles.forEach(bubble => {
    if (!bubble.connected) {
      bubble.connected = true
      markAllConnected(bubble)
    }
  })
}

function dropDisconnectedBubbles() {
  bubbles.forEach(bubble => {
    findTouchingBubbles(bubble, bubbles)
    bubble.connected = false
  })
  playerBubble.connected = true
  var topBubbles = []
  bubbles.forEach(bubble => {
    if (bubble.y === 242) {
      bubble.top = true
      bubble.connected = true
      topBubbles.push(bubble)
    } else {
      bubble.top = false
    }
  })
  topBubbles.forEach(bubble => {
    markAllConnected(bubble)
  })
  bubbles.forEach(bubble => {
    if (!bubble.connected) {
      bubbles.splice(bubbles.indexOf(bubble), 1)
      fall(bubble)
    }
  })
}

function pop(bubble) {
  repeat(7, () => {
    bubble.radius += 1
  }, () => {
    repeat(3, () => {
      bubble.radius -= 7
    }, () => {
      if (bubble.y > arrow.y + 20) {
        dropDisconnectedBubbles()
      }
      bubble.delete()
    })
  })
}

function fall(bubble) {
  var speed = 3
  repeatUntil(() => bubble.y < arrow.y + 20, () => {
    bubble.y -= speed
    speed *= 1.12
  }, () => {
    pop(bubble)
  })
}

</script>
</body>
	
</html>